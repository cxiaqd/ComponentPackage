# CSS每日3+1

## 一、圣杯布局和双飞翼布局的理解和区别，并用代码实现

作用：圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。

区别：
圣杯布局:为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。
双飞翼布局:为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。

## 二、隐藏页面元素的方法

### 1、diplay:none

这种方法是最常用的隐藏元素的方法，可以让元素在网页中完全消失，不会占据页面上的任何空间，用户无法看到或进行交互。
但是，这样也会导致元素脱离文档流，可能会影响其他元素的布局。

### 2、visibility:hidden

visibility 属性是专门用于控制元素的显示和隐藏，当它的值设置为 hidden 后，也会将元素隐藏。
但与 display 不同的地方在于，此时元素仍会占据页面上的空间，只是在视觉上不可见，显示为空白区域(所占区域为元素的大小)。
这种方式也是无法进行元素的响应事件监听和交互状态，通常应用于需要隐藏但仍需要占据空间的元素，如占位符、提示信息等。

### 3、opacity: 0

opacity 属性用于控制元素的透明度，取值范围：0/1，0 表示完全透明，1 表示不透明。
当我们将元素的 opacity 属性设置为 0 时，该元素将会变为不可见状态，不过它仍会占据页面上的空间。
这种方式隐藏的元素，都是视觉上不可见，和 visibility:hidden 比较类似。
但不同的地方在于：opacity: 0 设置元素不可见以后，用户仍然能够与该元素进行交互，而 visibility:hidden 则不行。

### 4、position

position 属性用于控制元素的定位方式，可以将元素在页面的不同位置进行定位，有多个取值，也是css中非常重要的属性，但我们这里只讨论如何隐藏元素。
当 position 取值相对定位或者绝对定位时，给定(left/top/right/bottom)四个方向上的任意一个较大的值(或负值)，都能将元素设置到屏幕之外，达到不可见的状态。

在使用上，相对定位和绝对定位有一定的区别。
绝对定位的元素会脱离当前文档流，整个从视觉上完全消失，效果上与 display:none 相似。
而相对定位则只是将元素移出，在当前位置仍然会占据一定的空间，效果上与 visibility:hidden 较相似。
但使用的定位的方式使元素不可见，都无法再与元素进行交互操作。
在绝对定位时，还可以通过 z-index 属性将元素的层级调低，让它被其他元素遮挡，达到一定的隐藏效果。

### 5、clip-path:circle(0%)

clip-path 属性，允许用不同的剪切方式创建元素的可显示区域，区域内的内容可以展示，区域外的内容则隐藏。之前也有博文详细介绍该属性，clip-path详解
根据它的特点，如果将元素的所有内容都设置到显示区域外，则元素就自动隐藏了，达到不可见的状态，而要实现这点只需要剪切区域设置为0，有多个形状值可以实现：`.elem {clip-path: circle(0%);clip-path: inset(50%);clip-path: polygon(0 0)}`
这种方式隐藏的元素，虽然不可见，但仍然会占据自身大小的空间，效果上与 visibility:hidden 相似。并且也不能响应事件监听和各种交互状态。

### 6、filter:blur(500px)

filter 属性是CSS3开始提供的，用于对页面元素设置各种滤镜效果，有大概十多个各种不同的滤镜值可以设置，我们这里使用 blur 模糊效果来达到隐藏页面元素的效果。
只需要将 blur() 值设置为一个较大的值，元素将模糊到无法显示的地方，如值大于400：`.elem {filter: blur(500px)}`
通过以上代码，就能将元素进行隐藏了，他的效果与使用 opacity: 0 一样，元素虽不可见，但仍占据空间，并且能够响应事件和交互状态。
**注意**：filter:opacity(0) 透明滤镜与 opacity: 0 也一样。

### 7、HTML Element 的 hidden 属性

通过设置页面元素(Element)的 hidden 属性，也能够将元素进行隐藏，它达到的效果与 display:none 几乎一样，元素脱离文档流、不可见，不占用空间，无法响应事件和用户交互等。
`<div hidden>这个元素将被隐藏，不占用空间，无法交互。</div>`
以上方式，针对的页面元素，是不区分块状元素和行内元素，都能够达到隐藏效果，下面还有几种方式，可能针对特定的元素才起作用。

### 8、transform:scale(0)

transform 属性用于对元素进行变换，例如旋转、缩放、平移等。其中，缩放 scale 就可以用来隐藏元素使用，只需要将 scale 的值设置为 0，该元素就会被缩放到不可见的状态，达到隐藏效果：`.elem {transform: scale(0)}`
需要注意的是，transform:scale(0) 达成的隐藏效果，无法作用于行内元素，这是由于 transform 属性本身对行内元素不起作用。
并且，这种隐藏方式也会占用页面空间(元素的原始大小区域)，但元素实际上宽高都为0，同样无法响应事件和交互。

## CSS选择器有哪些

优先级由高到低：!important > 内联style > ID选择器 > 类选择器 > 标签选择器 > 通配符选择器>继承

### 1、通配符选择器

### 2、标签选择器

### 3、类选择器

### 4、id选择器

### 5、属性选择器

```css
/* 存在 title 属性的 <a> 元素 */
a[title] {
  color: purple;
}

/* 存在 href 属性并且属性值匹配"https://example.org"的 <a> 元素 */
a[href="https://example.org"]
{
  color: green;
}

/* 存在 href 属性并且属性值包含"example"的 <a> 元素 */
a[href*="example"] {
  font-size: 2em;
}

/* 存在 href 属性并且属性值结尾是".org"的 <a> 元素 */
a[href$=".org"] {
  font-style: italic;
}

/* 存在 class 属性并且属性值包含单词"logo"的<a>元素 */
a[class~="logo"] {
  padding: 2px;
}
```

### 6、交集选择器

class值不用任何东西隔开，表示“且”--同时满足多个选择器筛选条件的才能被选中
筛选class值同时具有red和fontsize50的标签:`.red.fontsize{color:red}`
筛选class值为blue的P标签：`p.blue{color:blue}`

### 7、并集选择器

class值用“,”隔开，表示或--只要满足其中一个筛选条件就能够被选中
筛选class值为red或orange的标签：`.red,.orange{font-size:30px}`

### 8、后代选择器

（通常用单个空格（" "）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。`ul.my-things li {margin: 2em;}`

### 9、子选择器

（>）被放在两个 CSS 选择器之间。它只匹配那些被第二个选择器匹配的元素，这些元素是被第一个选择器匹配的元素的直接子元素。

```css
/* 选择属于“my-things”类的无序列表（ul）的直接子列表元素（li） */
ul.my-things > li {
  margin: 2em;
}
```

### 10、兄弟选择器

#### （1）、接续兄弟选择器

（+）介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中。

```css
/* 图片后面紧跟着的段落将被选中 */
img + p {
  font-weight: bold;
}
```

#### (2)、后续兄弟选择器

（~）将两个选择器分开，并匹配第二个选择器的所有迭代元素，位置无须紧邻于第一个元素，只须有相同的父级元素。

```css
<p>Here is a paragraph.</p>
<code>Here is some code.</code>
<span>And here is a red span!</span>
<span>And this is a red span!</span>

p ~ span {
  color: red;
}
```

### 11、嵌套选择器

CSS & 嵌套选择器明确指示在使用 CSS 嵌套时，父规则和子规则的关系。它使得内嵌子规则的选择器相对于其父元素。若没有 & 嵌套选择器，则子规则将选择子元素。

```css
.parent-rule {
  /* 父规则的属性 */
  :hover {
    /* 子规则的属性 */
  }
}
```

### 12、伪选择器

#### （1）、伪类选择器

| 伪类选择器 | 作用 | 应用对象
|-----------|-----|---------|
| :hover| 定义标记在鼠标悬停（划过）时的样式 |所有显示标记
| :link| 定义标记在超链接状态下的样式|a标签
| :focus| 定义标记在获取焦点时的样式|a标签（IE浏览器不支持）
| :visited| 定义标记被访问过后的样子|a标签
| :active| 定义标记在选定时刻下的样子|a标签

#### （2）、伪对象选择器

|伪对象选择器|作用|
|-----------|---|
|:first-leter|定义文本的第一个字符样式|
|:first-line|定义文本的首行样式|
|:before|定义对象之前内容的样式|
|:after|定义对象之后内容的样式|

## css3新增伪类

**elem:nth-child(n)**：选中父元素下的第n个子元素，并且这个元素后面的标签名为elem，n可以是具体的数值也可以是函数。
**elem:nth-last-child(n)**：作用同上，不过是从后开始查找。
**elem:last-child**：选中最后一个子元素。
**elem:only-child**：如果elem是父元素下唯一的子元素，则选中之。
**elem:nth-of-type(n)**：查找第n个elem标签的元素。可以为一个函数。
**elem:first-of-type**：选中父元素下第一个elem类型的元素。
**elem:last-of-type**:选中父元素下最后一个elem类型的元素。
**elem:only-of-type**:如果父元素下的子元素只有一个elem类型的元素，则选中该元素。
**elem:empty**:选中不包含子元素和内容的elem类型的元素。
**elem:target**:选中当前活动的elem元素。
**elem:not(elem)**:选择非elem元素的每一个元素。
**elem:enabled**:控制表单控件的禁用状态。
**elem:disabled**:控制表单的禁用状态。
**elem:checked**:单选框和复选框被选中。

## 多媒体查询

```css
.example {
    padding: 20px;
    color: white;
}
/* 超小设备 (手机, 600px 以下屏幕设备) */
@media only screen and (max-width: 600px) {
    .example {background: red;}
}

/* 小设备 (平板电脑和大型手机，600 像素及以上) */
@media only screen and (min-width: 600px) {
    .example {background: green;}
}

/* 中型设备（平板电脑，768 像素及以上） */
@media only screen and (min-width: 768px) {
    .example {background: blue;}
} 

/* 大型设备（笔记本电脑/台式机，992 像素及以上） */
@media only screen and (min-width: 992px) {
    .example {background: orange;}
} 

/* 超大型设备（大型笔记本电脑和台式机，1200 像素及以上） */
@media only screen and (min-width: 1200px) {
    .example {background: pink;}
}
```

## em、px、rem、vh、vw的区别

首先，在我们的日常开发中，px作为一等公民，成为了我们使用最多的单位，其次是%以及em等单位。正常情况下，px可以适用大部分项目的开发，并且，具有良好的兼容性，但是从CSS3开始，浏览器对这些计量单位的支持又提升到了一个新的高度，陆续推出了rem,vh,vw以及vm等一些新的计量单位，利用这些单位，有好的帮助我们解决了开发响应式页面的问题，使得我们开发出来的页面可以适配不同分辨率的设备。

### 计量单位

在CSS的计量单位体系中，可以分为相对长度单位和绝对长度单位：

* 相对长度单位包括：em,ex,ch,rem,vw,vh,vmin,vmax,%
* 绝对长度单位包括：cm,mm,in,px,pt,pc

### px

即像素，由计算机基础或者设计基础的同学应该都比较了解，像素其实就是对应我们显示器上的一个个同等大小的点，因此，像素在计量单位体系中，属于绝对长度单位，之前看到过网上的一些争论关于px是否为绝对长度单位，我认为是属于绝对长度单位，因为即使在移动端中存在设备像素比，px实际大小不确定，但是从主观的角度出发，px的大小和元素与其他的属性无关。

#### px特点

* 兼容性好
* 使用方便

### em

em属于相对长度单位。相对对象为当前对象内文本的字体size，如果当前行内文本的字体尺寸未设置，则相对对象为浏览器的默认字体尺寸**1em=16px**。
一般情况下，为了简化font-size的换算，我们需要在css的body选择器中声明font-size=62.5%，使得em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em，也就是说只需要将你原来的px数值除以10，然后换上em作为单位即可。

#### em特点

* em的值不固定
* em会继承父级元素的字体尺寸
* em是相对长度单位，相对当前行内对象的文本尺寸，如未设置，则相对浏览器默认的字体尺寸

```css
<div class="outside">
  我是14px=14.rem
  <div class="innerside">我是12px=1.2rem</div>
</div>
html {
  font-size: 10px;  /* 公式16px*62.5%=10px */ 
} 
.outside {
  font-size: 1.4rem
} 
.innerside{
  font-size: 1.2rem
}
```

此时，.outside的font-size为14px，而.innerside的font-size为16px。

### rem

与em同理

### vh、vw

vw，就是根据窗口的宽度分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽）。同理，vh则为窗口的高度

这里的窗口分成几种情况：

在桌面端，指的是浏览器的可视区域
移动端指的就是布局视口
像vw、vh，比较容易混淆的一个单位是%，不过百分比宽泛的讲是相对于父元素：

对于普通定位元素就是我们理解的父元素
对于position: absolute;的元素是相对于已定位的父元素
对于position: fixed;的元素是相对于 ViewPort（可视窗口）

### 总结

px：绝对单位，页面按精确像素展示
em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值
rem：相对单位，可理解为root em, 相对根节点html的字体大小来计算
vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单

## 常见布局方式有哪些

<https://blog.csdn.net/qq_45406325/article/details/107732094>

### 标准流布局

标准文档流简称为标准流，默认按照文档的顺序从上到下，从左到右，遇块换行。

### 浮动布局

会带来高度塌陷问题（通过清除浮动或创建BFC来解决）

### 定位布局

position定位布局，常见属性：

* **static**静态定位（默认），不脱离文档流
* **relative**相对定位（默认），不脱离文档流
* **fixed**固定定位（默认），完全脱离文档流（浮起来），根据浏览器视口定位。
* **absolute**绝对定位（默认），完全脱离文档流（浮起来），`margin:0 auto`失效，float不能用，若有父元素有定位属性为relative、fixed、absolute时将根据父元素进行定位，反之根据浏览器定位。
* **sticky**粘性定位，可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。

### 弹性布局

flex布局

### 网格布局

Grid网格布局

### 多列布局

多列布局

### 响应式布局

响应式布局

* 1、设置meta标签
* 2、设置rem字体
* 3、设置媒体查询

## CSS盒子模型

<https://blog.csdn.net/2301_79175212/article/details/142603765>
盒子模型是CSS中用于描述HTML元素在页面上占据空间的方式。每个HTML元素都被视为一个矩形盒子，这个盒子由以下几个部分组成：

* 内容区（Content）：显示实际内容，如文本、图片等。
* 内边距（Padding）：内容与边框之间的空间，用于增加内容的可读性。
* 边框（Border）：围绕内容和内边距的线条，可以设置样式、宽度和颜色。
* 外边距（Margin）：边框外的空间，用于控制元素之间的间距。
* 通过这四个部分的组合，盒子模型决定了一个元素在页面上的大小和位置。

## CSS四种引入方式

* 1、**行内样式**：最简单的一种，直接在html标签中中使用style；缺点是HTML页面不纯净，文件体积大，不利于浏览器编译，后期维护不方便。
* 2、**内嵌样式**：就是将CSS代码写在head标签中
* 3、**外部样式**：
  * 链接样式：使用频率最高，最实用的样式，只需要在head标签上加上link就可以了`<link type="text/css" rel="stylesheet" href="style.css" />`
    优点：实现了页面框架代码与表现CSS代码的完全分离，使得前期编写代码和后期代码维护都十分方便
  * 导入样式：和链接样式比较相似，采用@import的样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。
  
  从属关系：link是HTML标签，可以通过rel="alternate stylesheet"指定候选样式，而@important是CSS提供的
  加载顺序：页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载， @important必须在样式规则之前，可以在CSS文件中引入其他文件
  加载区别：link最大限度支持并行下载，@important嵌套过多会导致串行下载，出现FOUC
    FOUC：当使用@import导入CSS时，会导致某些页面在IE出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象被称为“文档样式暂时失效”，简称FOUC。
    产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将会停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。
    解决办法：使用link标签将样式表放在文档head中。
  兼容性：@important只在IE5以上才能识别，而link是HTML标签，无兼容问题，可以使用@important对古老浏览器隐藏样式
  权重方面：link方式的样式的权重高于@important的权重

## style标签写在body前后有什么区别

* 一般情况下，页面加载时自上而下的。将style标签至于body之前，为的是先加载样式。
* 若是写在body标签之后，由于浏览器以逐行方式对html文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在windows的IE下可能会出现FOUC现象（页面闪烁）。

### flex设置成1和auto有什么区别

<https://segmentfault.com/q/1010000004080910>

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

* **flex-grow**属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
* **flex-shrink**属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
* **flex-basis**属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。同理，如下是等同的：

```css
.item {flex: 2333 3222 234px;}
.item {
    flex-grow: 2333;
    flex-shrink: 3222;
    flex-basis: 234px;
}
```

当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的：

```css
.item {flex: none;}
.item {
    flex-grow: 0;
    flex-shrink: 0;
    flex-basis: auto;
}
```

当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的：

```css
.item {flex: auto;}
.item {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: auto;
}
```

当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：

```css
.item {flex: 1;}
.item {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 0%;
}
```

当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）：

```css
.item-1 {flex: 0%;}
.item-1 {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 0%;
}
.item-2 {flex: 24px;}
.item-1 {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 24px;
}
```

当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：

```css
.item {flex: 2 3;}
.item {
    flex-grow: 2;
    flex-shrink: 3;
    flex-basis: 0%;
}
```

当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：

```css
.item {flex: 2333 3222px;}
.item {
    flex-grow: 2333;
    flex-shrink: 1;
    flex-basis: 3222px;
}
```

flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况：

* auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。
* content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。
* 百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。

举一个不同的值之间的区别：

```html
<div class="parent">
    <div class="item-1"></div>
    <div class="item-2"></div>
    <div class="item-3"></div>
</div>

<style type="text/css">
    .parent {
        display: flex;
        width: 600px;
    }
    .parent > div {
        height: 100px;
    }
    .item-1 {
        width: 140px;
        flex: 2 1 0%;
        background: blue;
    }
    .item-2 {
        width: 100px;
        flex: 2 1 auto;
        background: darkblue;
    }
    .item-3 {
        flex: 1 1 200px;
        background: lightblue;
    }
</style>
```

* 主轴上父容器总尺寸为 600px
* 子元素的总基准值是：0% + auto + 200px = 300px，其中

> * 0% 即 0 宽度
> * auto 对应取主尺寸即 100px
>
* 故剩余空间为 600px - 300px = 300px
* 伸缩放大系数之和为： 2 + 2 + 1 = 5
* 剩余空间分配如下：
>
> * item-1 和 item-2 各分配 2/5，各得 120px
> * item-3 分配 1/5，得 60px
>
* 各项目最终宽度为：

> * item-1 = 0% + 120px = 120px
> * item-2 = auto + 120px = 220px
> * item-3 = 200px + 60px = 260px

* 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设
* 而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间

## CSS Sprites的概念、原理、适用范围和优缺点

### CSS Sprites概念

<https://www.cnblogs.com/yangguoe/p/8466117.html>
CSSSprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。对于当前网络流行的速度而言，不高于200KB的单张图片的所需载入时间基本是差不多的，所以无需顾忌这个问题。

加速的关键，不是降低质量，而是减少个数。传统切图讲究精细，图片规格越小越好，重量越小越好，其实规格大小无所谓，计算机统一都按byte计算。客户端每显示一张图片都会向服务器发送请求。所以，图片越多请求次数越多，造成延迟的可能性也就越大。

CSS Sprites技术不新鲜，早在2005年 CSS Zengarden 的园主 Dave Shea 就在 ALA 发表对该技术的 详细阐述 。原先只在CSS玩家之间作为一种网页制作方法流传，后来出来个 14 Rules for Faster-Loading Web Sites , 技术人员之间竞相传阅，其中第一条规则Make Fewer HTTP Requests就提到CSS Sprites。于是这个小妖精就火了起来，甚至出现了在线生成工具，势不可挡也。近来国内很多blog都提到CSS Sprites，最著名的例子莫过于<http://www.google.co.kr/> 下方的那几个动画。最新发布的YUI中，也是使用到CSS Sprites，几乎都有的CSS装饰图都被一个 40×2000的图 包办。社交大站Facebook最近也使用了一个 22×1150的图片 承担了所有icon.一时间，CSS Sprites无处不在。

## 说说你对SVN和GIT的理解和区别

<https://www.cnblogs.com/ai888/p/18560399>
SVN (Subversion) 和 Git 都是版本控制系统，用于跟踪代码的变化并方便团队协作，但它们在底层机制和工作方式上有很大的区别，对前端开发者的体验也有影响。

### SVN (集中式)

* 集中式版本控制： SVN 使用集中式模型，所有代码存储在一个中央服务器上。开发者需要从服务器检出代码到本地，修改后再提交回服务器。
* 线性版本历史： SVN 的版本历史是线性的，像一条直线，每次提交都会递增版本号。
* 必须联网操作： 大多数操作，例如提交、查看历史记录等，都需要连接到服务器才能完成。这在网络不佳的环境下会很不方便。
* 分支和合并功能较弱： SVN 的分支和合并功能相对 Git 来说比较弱，操作较为复杂，容易出错。
* 占用空间较大： 每次检出都需要下载整个项目的完整代码，占用本地存储空间较大。

### Git (分布式)

* 分布式版本控制： Git 使用分布式模型，每个开发者都拥有完整的代码仓库副本，包括完整的历史记录。这意味着即使离线，开发者也可以进行提交、查看历史* 等操作。
* 非线性版本历史： Git 的版本历史是非线性的，像一个树状结构，支持分支和合并，可以更好地适应复杂的开发流程。
* 离线操作： 大多数操作可以在本地完成，无需联网。只有推送和拉取代码等少数操作需要联网。
* 强大的分支和合并功能： Git 的分支和合并功能非常强大且灵活，是其核心优势之一。创建、切换和合并分支都非常快速和简单，鼓励开发者使用分支进行并行开发和实验性功能的开发。
* 占用空间较小： Git 只需要下载一次完整的代码仓库，后续操作都是在本地进行，占用空间相对较小。

### 对前端开发者的影响

协作方式: Git 的分支模型更适合前端团队并行开发多个功能或维护多个版本的项目。
开发流程: Git 的灵活性可以更好地支持各种前端工作流程，例如 Gitflow、GitHub Flow 等。
代码管理: Git 的强大功能可以帮助前端开发者更好地管理代码，例如使用分支进行代码审查、使用标签标记版本等。
开源社区: 绝大多数前端开源项目都使用 Git 进行版本控制，熟悉 Git 对于参与开源项目至关重要。
性能: Git 的本地操作速度通常比 SVN 快很多，尤其是在大型项目中。

### 总结

虽然 SVN 仍然在一些项目中使用，但 Git 凭借其分布式特性、强大的分支和合并功能以及活跃的社区，已经成为主流的版本控制系统，尤其是在前端开发领域。 对于前端开发者来说，学习和掌握 Git 是必备技能。

## 什么是FOUC？如何避免FOUC

### FOUC是什么

FOUC即无样式内容闪烁，也可以称为文档样式短暂失效，主要就是指HTML已加载而样式表并未加载，此后样式表再加载而产生的闪烁现象。在引用css的过程中，如果方法不当或者位置引用不对，会导致某些页面在windows下的ie出现一些奇怪的现象。以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效，简称FOUC。
原因分析：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。

### 如何避免FOUC

#### 1、样式表前置

根据浏览器渲染的顺序，将CSS在<head>中引入或者嵌入，相对于将CSS放到<body>或者页面底部来说，可以使页面渲染速度加快，这对于页面内容比较丰富的网站后者网络链接较慢时相当重要。
假如将样式表放置于底部，就会导致浏览器还未加载样式表就开始渲染页面，无法渐进式渲染页面而直接从无样式状态立即跳转到有样式状态，就会造成FOUC，用户体验较差；
此外有些浏览器可能会在CSS下载完成后才开始渲染页面，样式表放在下面会导致页面渲染推迟。

#### 2、尽量使用<link>而避免使用@import

当HTML文件被加载时，<link>引用的文件会同时被加载，而@import引用的文件则会等页面全部下载完毕再被加载，所以有时候浏览器@import加载CSS的页面时会没有样式，会出现FOUC现象，网速慢的时候就比较明显。
此外当<link>与@import混用可能会对页面有负面影响，在一些低版本IE中<link>与@import混用会导致样式表文件逐个加载，破坏并行下载的方式导致页面加载变慢。
此外无论哪种浏览器，若在<link>中引入的CSS中继续使用@import加载外部CSS，同样会导致顺序加载而不是并行加载，因为浏览器需要先解析<link>引入的CSS发现@import外部CSS后再次引入外部CSS，这就导致页面加载变慢。

## CSS属性content有什么作用？在哪些场景可以用到？

<https://blog.csdn.net/wuzhiyue2/article/details/117991671>

CSS的content属性在元素的::before和::after伪元素中插入生成的内容。它本身并不直接作用于元素本身，而是作用于这些伪元素，允许你在元素内容后面或者前面添加内容，而无需修改HTML结构。
**content属性的主要作用是插入各种类型的内容，包括：**

* 字符串：可以使用单引号或双引号插入文本字符串。
* 图像：使用url()函数插入图像。
* 计数器：使用content()或countes()函数插入计数器的值。这对于创建自动编号列表或章节非常有用。
* 属性值：使用attr()函数插入元素的属性值。这可以用于显示元素的title属性或其他自定义属性。
* 引号：使用open-quote和close-quote插入引号，并根据语言环境自动调整引号样式。
* 无内容：使用no-content或normal表示不插入任何内容。normal是默认值。

**content属性的应用场景非常广泛，一些常见的例子包括：**

* 清除浮动：结合::after伪元素和clear:both;可以清除浮动元素带来的布局问题。
* 插入图标：可以使用content属性和字体图标库来插入图标，而无需使用额外的HTML元素。
* 创建复杂的CSS形状：结合::before和::after伪元素，以及其他CSS属性，可以创建各种复杂的几何形状，例如三角形、箭头等。
* 生成自动编号列表：使用计数器可以轻松创建有序列表，而无需手动添加数字。
* 显示提示信息：可以使用attr()函数显示元素的title属性作为提示信息，或者使用自定义属性存储更丰富的信息。
* 自定义样式的引号：使用open-quote和close-quote可以根据语言环境自动调整引号样式，避免手动添加不同类型的引号。
* 插入特殊字符串：使用Unicode字符的转义序列，例如：content:'\2713';可以插入一个勾号（√）。
