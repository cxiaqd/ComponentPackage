# HTML每日3+1

## 一、 页面导入样式时，使用link和@import有什么区别？

1、方式不同：link是html标签，而@import是css规则
2、加载顺序：当页面加载时，link标签会同时加载和渲染外部样式文件，而@import规则会在页面加载完毕后再加载外部样式文件。
3、兼容性： link标签具有更好的兼容性，适用于所有浏览器。而@import规则在一些较旧的浏览器中可能会出现兼容新问题。
4、引用方式：link标签通过href属性引用外部样式文件，例如：`<link rel=stylesheet href="styles.css">`
而@import规则通过在CSS文件中使用@import关键字来引用外部样式文件，例如：`@import url("styles.css")`
5、权重影响：由于加载顺序的不同，link标签中的样式表具有更高的权重，可以覆盖@import规则中的样式。
6、dom可控性区别：可以通过js操作DOM，是否插入link标签来起到改变样式的作用；由于DOM方法是基于文档的，无法使用@import的方式插入样式。
**总的来说，推荐使用link标签来导入样式文件，因为它具有更好的兼容性和加载效果，并且能够更灵活地控制样式表的加载顺序和权重。**

## 二、HTML5的离线储存（工作原理+使用场景+真实使用步骤）

<https://blog.csdn.net/weixin_55846296/article/details/131049625>

### 前言

HTML5提供了一种称为离线存储（offline storage）的功能，它允许Web应用程序在浏览器离线时继续访问相关资源，以提高Web应用程序的性能和用户体验。
离线存储是通过在客户端（浏览器）中缓存Web应用程序的数据和文件来实现的。一旦缓存，Web应用程序将像普通应用程序一样在离线状态下继续运行。

### （一）、工作原理

使用HTML5离线缓存的原理是将Web一个用程序的核心文件（HTML、CSS、JavaScript等）缓存到客户端本地存储，以便在访问Web应用程序时无需从网络上下载，
从而提高Wen应用程序的性能和可靠性。
一般情况下，Web应用程序的资源是由浏览器从远程服务器中获取的，这需要进行网络请求，当用户访问的页面存在大量资源时，网络请求的事件可能变得很耗时，从而导致Web应用程序的性能下降。而HTMl5离线缓存可以有效避免这种情况得的发生。
**HTML5离线工作缓存的工作原理是**：在HTML文件的头部使用manifest属性引用清单文件，在清单文件中列出要缓存的文件。当Web应用程序首次加载时，浏览器会下载这些文件并将它们缓存到本地中。当Web应用程序下一次被打开时，如果网络连接不可用，浏览器将从本地缓存中获取需要的资源，从而避免了网络请求。
当Web应用程序第二次请求时，浏览器会检查manifest文件中的缓存清单，检查缓存清单中列出的文件是否已经被更改，如果没有改变，浏览器会读取已缓存的文件，否则，浏览器会下载最新的文件并更新缓存文件。
无论使用什么样的技术来实现，HTML5的离线缓存原理都是将数据和资源缓存到本地，当用户再次访问时，不需要从服务端获取数据，而是直接从本地缓存中读取。这种方式可以提高Web应用程序的性能和可靠性，并减少用户等待时间。

### （二）、使用场景

HTML5提供的离线缓存技术具有一定的应用场景，它可以在一些特定的情况下帮助Web应用程序提升用户体验和性能，常见的使用场景包括：

#### 移动设备应用

HTML5离线缓存适用于移动设备应用，用户可以在不在线的情况下快速方便地访问Web应用程序。

#### 新闻网站、博客等

对于一些内容类型比较固定的站点，可以使用离线缓存将一些静态资源缓存到本地，减少对服务器的请求次数，提高页面访问速度和用户体验。

#### 游戏应用程序

游戏应用程序常需要加载大量的资源文件，在使用离线缓存后可以快速地从本地缓存中加载文件，提高游戏体验。

#### 网络教育平台

HTML5离线缓存适用于一些在线的教育平台以及具有固定内容的文档等，可以提升用户跨网络使用体验。

#### 电子商务平台

对于电子商务平台，可以将电商页面的基础数据、商品数据等内容通过离线储存到本地，以便在离线状态下能够查询商品信息，提升用户购物体验。
**总之，HTML5离线缓存技术适用于对于页面内容不经常更新，静态资源多的场景，可以提高访问速度和用户体验。但对于更新频繁、动态资源多的场景并不适用**

### （三）、使用步骤

使用HTML5离线缓存大致需要以下几个步骤：

#### 1、创建并配置缓存清单

**缓存清单文件**是一个文本文件，它包含一个或多个**CACHE、NETWORK**和**FALLBACK**部分。他们用于将需要缓存的文件和资源列出来，并指定哪些文件或资源需要联网或在出现故障时使用备用资源。**文件名必须指定其相对路径或绝对路径**，以便在下载时引用他们。
例如，下面是一个简单的缓存清单示例：

```json
CACHE MANIFEST

CACHE:
index.html
css/style.css
js/main.js

NETWORK:
*

FALLBACK:
/test.html /fallback.html
```

这个清单文件中分别包含了CACHE、NETWORK和FALLBACK三个部分。

* **CACHE**中列出了徐要缓存的文件；
* **NETWORK**中表示所有其他文件要求在线；
* **FALLBACK**中指定了当某个文件无法下载时应该使用哪个备用文件。

在以上示例中，指定了对/test.html文件进行备份，当/test.html无法下载时将返回fallback.html文件。

#### 2、将缓存清单与HTML文件相关联

在HTML文档的`<head>`部分中添加以下代码，指向缓存清单文件：

```html
<!DOCTYPE html>
<html manifest="/demo.appcache">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5离线缓存</title>
    <link rel="manifest" href="/demo.appcache" />
</head>
<body>
    ...
    <script src="jquery.min.js"></script>
    <script src="main.js"></script>
</body>
</html>
```

#### 3、使用javaScript调用应用程序缓存对象

HTML5使用**window.applicationCache**来访问应用程序缓存。应用程序缓存对象提供许多方法和事件，允许检查缓存状态、更新缓存、监视进度等。列如，以下时一些基本的API：

```js
var appCache = window.applicationCache;
appCache.update();
appCache.addEventListener('updateready', function(e){
  if (appCache.status == appCache.UPDATEREADY) {
    appCache.swapCache(); // We have a new updated offline cache, let's use it
  }
}, false);
```

在以上示例中，update()方法立即启动下载当前清单文件的过程，如果下载的清单文件与之前缓存的不同表示可以更新后，就依次调用swapCache()来交换缓存，使浏览器使用新的清单文件。
请注意，与网络缓存相关的事件也会触发。例如：当一个资源已下载并缓存完毕时，progress事件会被触发，并返回下载进度。

#### 4、测试离线缓存

将这个项目目录复制到一个没有互联网连接的测试服务器上。禁用网络连接并使用浏览器登录到该HTML文件。如果一切正常，浏览器应该使用本地应用程序缓存来加载和运行应用程序，并在缺少互联网连接时保持运行。
总之，在使用HTML5离线缓存时，需要编写缓存清单文件、将清单文件与HTML文件关联、使用javsScript调用应用程序缓存对象、以及测试离线缓存是否正确。通过以上几个步骤，可以以很低的代价实现Web应用程序的离线访问功能，提高用户体验。

### （四）、注意事项

使用HTML5离线存储技术需要注意以下几点：

1. 缓存的资源必须在同一域名下。
2. 一旦您的浏览器实现了HTML5离线缓存，缓存的文件在客户端将一直保留着，除非您手动清除浏览器的缓存。
3. 如果应用程序涉及到修改缓存清单文件，浏览器将重新下载缓存清单文件和所有列出的文件。
4. 请确保您要缓存的资源文件与缓存清单文件中指向的URL（包括子目录和查询字符串）完全匹配，否则会导致离线缓存失效。
5. 由于离线缓存是在客户端进行的，因此不会影响服务器端缓存或CDN缓存。
6. 每个缓存在浏览器中的资源文件大小不能超过50M。
7. 对于很少更新的文件，如图片或视频，使用离线缓存可以帮助您减少对服务器的访问次数。但是对于经常变化的内容，如动态生成的页面或者一些需要更新的脚本，离线缓存不太适用。
8. 使用离线缓存时，应当在每个请求中添加一个特殊的HTTP头，以确保缓存清单文件及时更新，以避免应用程序脱离同步。例如:

```html
<html manifest="demo.appcache">
<head>
  <meta http-equiv="CACHE-CONTROL" content="no-cache">
  ...
</head>
<body>
  ...
</body>
</html>
```

最后，使用HTML5离线存储技术需要谨慎使用。虽然它可以帮助提高Web应用程序的性能和用户体验，但不适用于所有类型的Web应用程序。在使用HTML5离线存储技术之前，请仔细评估您的应用程序需要和性能需求，并选择正确的技术方案。

## 三、前端本地存储方案

<https://cloud.tencent.com/developer/article/2332927>
<https://blog.csdn.net/weixin_45709829/article/details/123963260>

## iframe框架

## BFC

<https://blog.csdn.net/sinat_36422236/article/details/88763187>

## 清除浮动的方式有哪些

* 为什么要清除浮动
清除浮动主要是为了解决，父元素因为子集元素浮动引起的内部高度为0的问题（当父元素不给高度且内部元素设置浮动时，内部元素不会将父元素撑开，此时父元素就会变成一条线）
* 四种清除浮动的方法
1、额外标签法（在最后一个浮动标签后，新增一个标签，给其设置clear:both）（不建议使用）
优点：通俗易懂，方便
缺点：添加无意义标签，语义化差
2、通过BFC的方式实现清除浮动，父级添加overflow属性（父元素添加overflow:hidden）(不推荐)
优点：代码简洁
缺点：内容增多的时候容易造成不会自动换行被隐藏掉，无法显示要溢出的元素
3、使用after伪元素（添加到父级元素上）（推荐）
优点：符合闭合浮动思想，结构语义化正确
缺点：ie6-7不支持伪元素-after，可使用zoom:1触发hasLayout
4、使用before和after双伪元素（添加到父级元素上）（推荐）
优缺点同上

## label的作用

在前端开发中，label标签具有多种作用，主要用于提升用户体验、增强可访问性、美化界面以及优化搜索引擎优化（SEO）效果。以下是label标签的主要作用及相应例子：

* 提供表单元素标签或说明文本：
作用：帮助用户理解表单元素的用途和如何与之交互。
例子：在登录表单中，使用`<label for="username">用户名:</label>`为用户名字段提供标签，使用户明确知道该输入框用于输入用户名。

* 增强可访问性：
作用：屏幕阅读器等辅助技术可以读取label元素的文本，并将其与关联的表单控件关联起来，帮助残障用户更容易地理解表单结构和填写方法。
例子：对于视觉障碍用户，屏幕阅读器会读出“用户名:”这样的label文本，并告知用户接下来的输入框与之相关联。

* 扩大点击区域：
作用：将文本包装在label中可以扩大点击区域，特别是在移动设备上，使得点击大型输入区域更容易。
例子：在复选框或单选按钮旁使用label标签，如`<label><input type="checkbox">我同意条款</label>`，用户点击“我同意条款”文本时也能选中复选框。

* 美化和定制界面：
作用：通过CSS可以自定义label元素的样式，使表单更具吸引力或符合特定设计需求。
例子：使用CSS为label元素添加样式，如改变颜色、字体大小或添加悬停效果，以提升表单的视觉吸引力。

* 提高页面语义化：
作用：使用label标签能够明确文本与相关表单字段之间的关系，提高HTML文档的语义化程度，使其更具可读性和易维护性。
例子：在表单中使用恰当的label标签，有助于搜索引擎和开发者更好地理解页面结构和内容。

* 优化SEO效果：
作用：搜索引擎会将label标签中的文本作为关键词来处理，有助于提高页面的搜索引擎优化效果。
例子：合理设置label文本，可以包含与页面内容相关的关键词，从而提升页面在搜索引擎中的排名。

**综上所述**，label标签在前端开发中发挥着重要作用，不仅提升了用户体验和可访问性，还能增强页面语义化和优化SEO效果。因此，在编写HTML表单时，建议始终使用label标签为表单元素添加合适的文本标签。

## 浏览器内多个标签页之间的通信方式

<https://blog.csdn.net/weixin_46399753/article/details/105211771>

### 一、cookie+seniterval方式

### 二、SharedWorker

### 三、BroadcastChannel

### 四、localStorage

## 简述下你理解的渐进增强和优雅降级

### 1、什么是渐进增强

在网页开发中，渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验,换句话说，就是以最低要求，实现最基础功能为基本，向上兼容。

### 2、什么是优雅降级

在网页开发中，优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较 大的错误之外，其它的差异将被直接忽略。也就是以高要求，高版本为基准，向下兼容。
3.两者之间的区别
优雅降级和渐进增强只是关注同一网站在不同设备里和不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。
优雅降级认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器的前一个版本。在这种设计下，旧版的浏览器被认为仅能提供最简单的的浏览体验
渐进增强认为应关注于内容本身。会优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性，这使得渐进增强成为一种更为合理的设计范例

### 两者之间的区别

优雅降级和渐进增强只是关注同一网站在不同设备里和不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。
优雅降级认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器的前一个版本。在这种设计下，旧版的浏览器被认为仅能提供最简单的的浏览体验
渐进增强认为应关注于内容本身。会优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性，这使得渐进增强成为一种更为合理的设计范例

### 代码举例

```css
.transition { /渐进增强写法，先关注最高级的再考虑兼容/
-webkit-transition: all .5s;
-moz-transition: all .5s;
-o-transition: all .5s;
transition: all .5s;
}
.transition { /优雅降级写法，先考虑兼容/
transition: all .5s;
-o-transition: all .5s;
-moz-transition: all .5s;
-webkit-transition: all .5s;
}
```

## viewport常见设置有哪些

viewport在前端开发中是一个重要的概念，特别是在进行响应式设计和移动Web开发时。它主要用于设置网页在移动设备上的可视区域，以确保网页能够正确地适应不同尺寸的屏幕。以下是viewport的一些常见设置：
**width**：设置viewport的宽度。这个值可以是一个具体的像素值，也可以是特殊的值，如'device-width'，表示设备的屏幕宽度。使用'device-width'可以确保网页的宽度与设备的屏幕宽度相匹配，从而避免水平滚动条的出现。
**initial-scale**：设置网页首次加载时的缩放比例。这个值是一个数值，表示相对于原始大小的缩放倍数。例如，1.0表示不缩放，即按照原始大小显示。这个属性通常与width属性一起使用，以确保网页在加载时能够正确地适应屏幕。
**maximum-scale** 和 **minimum-scale**：分别设置用户允许缩放的最大比例和最小比例。这两个属性可以防止用户过度缩放网页，从而保持网页的布局和可读性。
**user-scalable**：设置是否允许用户手动缩放网页。这个属性可以接受两个值：'yes'或'no'。如果设置为'no'，则用户无法通过手势或浏览器控件来缩放网页。这有助于保持网页的布局稳定性，但也可能限制用户的交互体验。

综上所述，一个常见的viewport设置示例如下：
在前端开发中，meta视口标签是构建响应式网页不可缺或缺的一部分，它位于HTML文档的头部，这个标签的作用是告诉浏览器如何控制页面的尺寸和缩放比例。视口标签的一般格式如下：
`<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">`
这个设置将viewport的宽度设置为设备的屏幕宽度，初始缩放比例为1.0，并禁止用户手动缩放网页。这样的设置通常适用于响应式设计，可以确保网页在不同设备上都能够正确地显示和布局。

## 标签语义化的理解

<https://segmentfault.com/a/1190000045465892>

## html5中的form怎么关闭自动完成功能

<https://docs.pingcode.com/baike/3090637>

## ::before和::after中单冒号和双冒号的区别

伪类使用单冒号表示，伪元素既可以是单冒号，也可以是双冒号，规范使用建议是双冒号。

* **::before** 伪元素：用于在选定元素的内容前插入一个生成的内容。它允许在元素的开始位置插入额外的样式化内容，通常用于添加装饰性的元素或图标。
例如，可以使用 ::before 创建一个元素的前置图标。
* **::after** 伪元素：用于在选定元素的内容后插入一个生成的内容。它允许在元素的结束位置插入额外的样式化内容，通常用于添加装饰性的元素或生成清除浮动的伪元素。
例如，可以使用 ::after 创建一个元素的尾部装饰。
这两个伪元素的内容可以通过 content 属性来定义（content不能没有，内容至少为空；伪元素的display默认为inline）。

### 常见的伪元素

* ::first-line：用于选中元素的第一行文本，可以对其应用特定的样式。
* ::first-letter：用于选中元素的第一个字母，可以对其应用特定的样式。
* ::selection：用于选中文本时的样式，例如文本的背景色和文本颜色等。
* ::placeholder：用于设置表单元素的占位符文本的样式，允许自定义占位符文本的颜色、字体等。

### 常见的伪类

单冒号(:)用于表示 CSS 中的伪类，它们是一些用于选择特定状态或特定位置的元素的类别。以下是一些常见的单冒号伪类：

* :hover：当鼠标悬停在元素上时应用的样式。
* :active：当元素被激活或被点击时应用的样式。
* :focus：当元素获得焦点时应用的样式，通常在用户与表单元素进行交互时使用。
* :visited：选择已访问过的链接的样式。
* :first-child：选择父元素下的第一个子元素。
* :last-child：选择父元素下的最后一个子元素。
* :nth-child(n)：选择父元素下的第 n 个子元素。
* :nth-of-type(n)：选择父元素下同类型元素中的第 n 个元素。
* :not(selector)：选择不满足指定选择器的元素。
* :empty：选择没有子元素或者没有文本内容的元素

## 常见状态码

||类别|原因短语|
|-|--|--|
|1xx|Informational（信息状态码）|接受的请求正在处理|
|2xx|Success（成功状态码）|请求正常处理完毕|
|3xx|Redirection（重定向状态码）|需要进行附加操作以完成请求|
|4xx|Client Error（客户端错误状态码）|服务器无法处理请求|
|5xx|Server Error（服务器错误状态码）|服务器处理请求报错|

### 2XX 成功

* 200 ok（请求成功）
* 204 no content （请求成功，但是没有结果返回）
* 206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）

### 3XX 重定向

* 301 move permanently （永久性重定向）
* 302 found （临时性重定向）
* 303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET

### 方法定向获取请求的资源）

* 304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）
* 307 temporary redirect （跟302一个意思）

### 4XX 客户端错误

* 400 bad request （请求报文存在语法错误）
* 401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））
* 403 forbidden （请求被服务器拒绝了）
* 404 not found （服务器上无法找到请求的资源）

### 5XX 服务器错误

* 500 internal server error （服务端执行请求时发生了错误）
* 503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）

## 为什么HTML5只需要写`<!DOCTYPE html>`就可以

在Web开发的早期，定义文档类型（DOCTYPE）是确保浏览器正确解析和显示网页的关键步骤。随着HTML的进化，HTML5简化了DOCTYPE声明，只需要写`<!DOCTYPE html>`。

### DOCTYPE的历史背景

在HTML4及之前的版本中，DOCTYPE声明是非常复杂的，并且与特定的DTD（Document Type Defination）相关联。DOCTYPE的主要目的是告诉浏览器使用哪种HTML或XML规则来解析文档。如果没有正确说明，浏览器可能会进入怪异模式（Quirks Mode），导致页面渲染不一致。

* HTML4的一个典型DOCTYPE声明如下
`<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">`
这种声明不仅冗长，而且容易出错，给开发者带来了不少困扰。

### HTML5的简化

HTML5的设计目标之一是简化Web开发过程，并提高兼容性和易用性。因此，HTML5的DOCTYPE声明被大大就简化，只需要`<!DOCTYPE html>`
这种简化的声明具有以下几个显著优势：

* 1、简洁明了
HTML5的DOCTYPE声明非常简洁，只需要一行代码就能完成。这使得文档结构更加清晰，减少了开发者记忆和输入的负担。
* 2、浏览器兼容性
尽管DOCTYPE声明在不同的HTML版本中有所不同，HTML5的简化声明在所有现代浏览器中都能正常工作。浏览器会将其解释为标准模式（Standards Mode），从而确保页面的一直渲染。这种统一性极大地减少了浏览器兼容性问题。
* 3、向前向后兼容
HTML5的DOCTYPE声明不仅向前兼容（适用于未来的HTML版本），还向后兼容（适用于旧的HTML版本），这意味着你在使用HTML5的DOCTYPE声明，旧的HTML4文档也能正常显示，而且新的HTML5特性也能无缝集成。
* 4、降低学习曲线
对于新手开发者来说，简化的DOCTYPE声明大大降低了学习曲线。他们不再需要记住复杂的DTD声明，只需记住一个简单的`<!DOCTYPE html>`即可。这样，可以更快地上手网页开发，专注于内容和功能本身。
* 5、符合HTML5哲学
HTML5强调简单和实用，这种哲学贯穿了整个规范的设计。简化的DOCTYPE声明正是这种哲学的体现，使得Web开发变得更加直观和易于维护。
**总结**
HTML5之所以只需要简化的`<!DOCTYPE html>`声明，主要是为了简化开发过程、提高浏览器兼容性、降低学习曲线，并且符合HTML5强调简单和实用的设计哲学。这种简化不仅使得Web开发更加高效，也确保了未来的兼容性和扩展性。通过采用这个简单的声明，开发者可以更专注于页面内容和功能，而不必担心复杂的DTD声明带来的麻烦。
