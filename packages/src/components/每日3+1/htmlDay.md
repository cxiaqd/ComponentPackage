# HTML每日3+1

## 一、 页面导入样式时，使用link和@import有什么区别？

1、方式不同：link是html标签，而@import是css规则
2、加载顺序：当页面加载时，link标签会同时加载和渲染外部样式文件，而@import规则会在页面加载完毕后再加载外部样式文件。
3、兼容性： link标签具有更好的兼容性，适用于所有浏览器。而@import规则在一些较旧的浏览器中可能会出现兼容新问题。
4、引用方式：link标签通过href属性引用外部样式文件，例如：`<link rel=stylesheet href="styles.css">`
而@import规则通过在CSS文件中使用@import关键字来引用外部样式文件，例如：`@import url("styles.css")`
5、权重影响：由于加载顺序的不同，link标签中的样式表具有更高的权重，可以覆盖@import规则中的样式。
6、dom可控性区别：可以通过js操作DOM，是否插入link标签来起到改变样式的作用；由于DOM方法是基于文档的，无法使用@import的方式插入样式。
**总的来说，推荐使用link标签来导入样式文件，因为它具有更好的兼容性和加载效果，并且能够更灵活地控制样式表的加载顺序和权重。**

## 二、HTML5的离线储存（工作原理+使用场景+真实使用步骤）

<https://blog.csdn.net/weixin_55846296/article/details/131049625>

### 前言

HTML5提供了一种称为离线存储（offline storage）的功能，它允许Web应用程序在浏览器离线时继续访问相关资源，以提高Web应用程序的性能和用户体验。
离线存储是通过在客户端（浏览器）中缓存Web应用程序的数据和文件来实现的。一旦缓存，Web应用程序将像普通应用程序一样在离线状态下继续运行。

### （一）、工作原理

使用HTML5离线缓存的原理是将Web一个用程序的核心文件（HTML、CSS、JavaScript等）缓存到客户端本地存储，以便在访问Web应用程序时无需从网络上下载，
从而提高Wen应用程序的性能和可靠性。
一般情况下，Web应用程序的资源是由浏览器从远程服务器中获取的，这需要进行网络请求，当用户访问的页面存在大量资源时，网络请求的事件可能变得很耗时，从而导致Web应用程序的性能下降。而HTMl5离线缓存可以有效避免这种情况得的发生。
**HTML5离线工作缓存的工作原理是**：在HTML文件的头部使用manifest属性引用清单文件，在清单文件中列出要缓存的文件。当Web应用程序首次加载时，浏览器会下载这些文件并将它们缓存到本地中。当Web应用程序下一次被打开时，如果网络连接不可用，浏览器将从本地缓存中获取需要的资源，从而避免了网络请求。
当Web应用程序第二次请求时，浏览器会检查manifest文件中的缓存清单，检查缓存清单中列出的文件是否已经被更改，如果没有改变，浏览器会读取已缓存的文件，否则，浏览器会下载最新的文件并更新缓存文件。
无论使用什么样的技术来实现，HTML5的离线缓存原理都是将数据和资源缓存到本地，当用户再次访问时，不需要从服务端获取数据，而是直接从本地缓存中读取。这种方式可以提高Web应用程序的性能和可靠性，并减少用户等待时间。

### （二）、使用场景

HTML5提供的离线缓存技术具有一定的应用场景，它可以在一些特定的情况下帮助Web应用程序提升用户体验和性能，常见的使用场景包括：

#### 移动设备应用

HTML5离线缓存适用于移动设备应用，用户可以在不在线的情况下快速方便地访问Web应用程序。

#### 新闻网站、博客等

对于一些内容类型比较固定的站点，可以使用离线缓存将一些静态资源缓存到本地，减少对服务器的请求次数，提高页面访问速度和用户体验。

#### 游戏应用程序

游戏应用程序常需要加载大量的资源文件，在使用离线缓存后可以快速地从本地缓存中加载文件，提高游戏体验。

#### 网络教育平台

HTML5离线缓存适用于一些在线的教育平台以及具有固定内容的文档等，可以提升用户跨网络使用体验。

#### 电子商务平台

对于电子商务平台，可以将电商页面的基础数据、商品数据等内容通过离线储存到本地，以便在离线状态下能够查询商品信息，提升用户购物体验。
**总之，HTML5离线缓存技术适用于对于页面内容不经常更新，静态资源多的场景，可以提高访问速度和用户体验。但对于更新频繁、动态资源多的场景并不适用**

### （三）、使用步骤

使用HTML5离线缓存大致需要以下几个步骤：

#### 1、创建并配置缓存清单

**缓存清单文件**是一个文本文件，它包含一个或多个**CACHE、NETWORK**和**FALLBACK**部分。他们用于将需要缓存的文件和资源列出来，并指定哪些文件或资源需要联网或在出现故障时使用备用资源。**文件名必须指定其相对路径或绝对路径**，以便在下载时引用他们。
例如，下面是一个简单的缓存清单示例：

```json
CACHE MANIFEST

CACHE:
index.html
css/style.css
js/main.js

NETWORK:
*

FALLBACK:
/test.html /fallback.html
```

这个清单文件中分别包含了CACHE、NETWORK和FALLBACK三个部分。

* **CACHE**中列出了徐要缓存的文件；
* **NETWORK**中表示所有其他文件要求在线；
* **FALLBACK**中指定了当某个文件无法下载时应该使用哪个备用文件。

在以上示例中，指定了对/test.html文件进行备份，当/test.html无法下载时将返回fallback.html文件。

#### 2、将缓存清单与HTML文件相关联

在HTML文档的`<head>`部分中添加以下代码，指向缓存清单文件：

```html
<!DOCTYPE html>
<html manifest="/demo.appcache">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5离线缓存</title>
    <link rel="manifest" href="/demo.appcache" />
</head>
<body>
    ...
    <script src="jquery.min.js"></script>
    <script src="main.js"></script>
</body>
</html>
```

#### 3、使用javaScript调用应用程序缓存对象

HTML5使用**window.applicationCache**来访问应用程序缓存。应用程序缓存对象提供许多方法和事件，允许检查缓存状态、更新缓存、监视进度等。列如，以下时一些基本的API：

```js
var appCache = window.applicationCache;
appCache.update();
appCache.addEventListener('updateready', function(e){
  if (appCache.status == appCache.UPDATEREADY) {
    appCache.swapCache(); // We have a new updated offline cache, let's use it
  }
}, false);
```

在以上示例中，update()方法立即启动下载当前清单文件的过程，如果下载的清单文件与之前缓存的不同表示可以更新后，就依次调用swapCache()来交换缓存，使浏览器使用新的清单文件。
请注意，与网络缓存相关的事件也会触发。例如：当一个资源已下载并缓存完毕时，progress事件会被触发，并返回下载进度。

#### 4、测试离线缓存

将这个项目目录复制到一个没有互联网连接的测试服务器上。禁用网络连接并使用浏览器登录到该HTML文件。如果一切正常，浏览器应该使用本地应用程序缓存来加载和运行应用程序，并在缺少互联网连接时保持运行。
总之，在使用HTML5离线缓存时，需要编写缓存清单文件、将清单文件与HTML文件关联、使用javsScript调用应用程序缓存对象、以及测试离线缓存是否正确。通过以上几个步骤，可以以很低的代价实现Web应用程序的离线访问功能，提高用户体验。

### （四）、注意事项

使用HTML5离线存储技术需要注意以下几点：

1. 缓存的资源必须在同一域名下。
2. 一旦您的浏览器实现了HTML5离线缓存，缓存的文件在客户端将一直保留着，除非您手动清除浏览器的缓存。
3. 如果应用程序涉及到修改缓存清单文件，浏览器将重新下载缓存清单文件和所有列出的文件。
4. 请确保您要缓存的资源文件与缓存清单文件中指向的URL（包括子目录和查询字符串）完全匹配，否则会导致离线缓存失效。
5. 由于离线缓存是在客户端进行的，因此不会影响服务器端缓存或CDN缓存。
6. 每个缓存在浏览器中的资源文件大小不能超过50M。
7. 对于很少更新的文件，如图片或视频，使用离线缓存可以帮助您减少对服务器的访问次数。但是对于经常变化的内容，如动态生成的页面或者一些需要更新的脚本，离线缓存不太适用。
8. 使用离线缓存时，应当在每个请求中添加一个特殊的HTTP头，以确保缓存清单文件及时更新，以避免应用程序脱离同步。例如:

```html
<html manifest="demo.appcache">
<head>
  <meta http-equiv="CACHE-CONTROL" content="no-cache">
  ...
</head>
<body>
  ...
</body>
</html>
```

最后，使用HTML5离线存储技术需要谨慎使用。虽然它可以帮助提高Web应用程序的性能和用户体验，但不适用于所有类型的Web应用程序。在使用HTML5离线存储技术之前，请仔细评估您的应用程序需要和性能需求，并选择正确的技术方案。

## 三、前端本地存储方案

<https://cloud.tencent.com/developer/article/2332927>
<https://blog.csdn.net/weixin_45709829/article/details/123963260>

## iframe框架

## BFC

<https://blog.csdn.net/sinat_36422236/article/details/88763187>

## 清除浮动的方式有哪些

* 为什么要清除浮动
清除浮动主要是为了解决，父元素因为子集元素浮动引起的内部高度为0的问题（当父元素不给高度且内部元素设置浮动时，内部元素不会将父元素撑开，此时父元素就会变成一条线）
* 四种清除浮动的方法
1、额外标签法（在最后一个浮动标签后，新增一个标签，给其设置clear:both）（不建议使用）
优点：通俗易懂，方便
缺点：添加无意义标签，语义化差
2、通过BFC的方式实现清除浮动，父级添加overflow属性（父元素添加overflow:hidden）(不推荐)
优点：代码简洁
缺点：内容增多的时候容易造成不会自动换行被隐藏掉，无法显示要溢出的元素
3、使用after伪元素（添加到父级元素上）（推荐）
优点：符合闭合浮动思想，结构语义化正确
缺点：ie6-7不支持伪元素-after，可使用zoom:1触发hasLayout
4、使用before和after双伪元素（添加到父级元素上）（推荐）
优缺点同上

## label的作用

在前端开发中，label标签具有多种作用，主要用于提升用户体验、增强可访问性、美化界面以及优化搜索引擎优化（SEO）效果。以下是label标签的主要作用及相应例子：

* 提供表单元素标签或说明文本：
作用：帮助用户理解表单元素的用途和如何与之交互。
例子：在登录表单中，使用`<label for="username">用户名:</label>`为用户名字段提供标签，使用户明确知道该输入框用于输入用户名。

* 增强可访问性：
作用：屏幕阅读器等辅助技术可以读取label元素的文本，并将其与关联的表单控件关联起来，帮助残障用户更容易地理解表单结构和填写方法。
例子：对于视觉障碍用户，屏幕阅读器会读出“用户名:”这样的label文本，并告知用户接下来的输入框与之相关联。

* 扩大点击区域：
作用：将文本包装在label中可以扩大点击区域，特别是在移动设备上，使得点击大型输入区域更容易。
例子：在复选框或单选按钮旁使用label标签，如`<label><input type="checkbox">我同意条款</label>`，用户点击“我同意条款”文本时也能选中复选框。

* 美化和定制界面：
作用：通过CSS可以自定义label元素的样式，使表单更具吸引力或符合特定设计需求。
例子：使用CSS为label元素添加样式，如改变颜色、字体大小或添加悬停效果，以提升表单的视觉吸引力。

* 提高页面语义化：
作用：使用label标签能够明确文本与相关表单字段之间的关系，提高HTML文档的语义化程度，使其更具可读性和易维护性。
例子：在表单中使用恰当的label标签，有助于搜索引擎和开发者更好地理解页面结构和内容。

* 优化SEO效果：
作用：搜索引擎会将label标签中的文本作为关键词来处理，有助于提高页面的搜索引擎优化效果。
例子：合理设置label文本，可以包含与页面内容相关的关键词，从而提升页面在搜索引擎中的排名。

**综上所述**，label标签在前端开发中发挥着重要作用，不仅提升了用户体验和可访问性，还能增强页面语义化和优化SEO效果。因此，在编写HTML表单时，建议始终使用label标签为表单元素添加合适的文本标签。

## 浏览器内多个标签页之间的通信方式

<https://blog.csdn.net/weixin_46399753/article/details/105211771>

### 一、cookie+seniterval方式

### 二、SharedWorker

### 三、BroadcastChannel

### 四、localStorage

## 简述下你理解的渐进增强和优雅降级

### 1、什么是渐进增强

在网页开发中，渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验,换句话说，就是以最低要求，实现最基础功能为基本，向上兼容。

### 2、什么是优雅降级

在网页开发中，优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较 大的错误之外，其它的差异将被直接忽略。也就是以高要求，高版本为基准，向下兼容。
3.两者之间的区别
优雅降级和渐进增强只是关注同一网站在不同设备里和不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。
优雅降级认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器的前一个版本。在这种设计下，旧版的浏览器被认为仅能提供最简单的的浏览体验
渐进增强认为应关注于内容本身。会优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性，这使得渐进增强成为一种更为合理的设计范例

### 两者之间的区别

优雅降级和渐进增强只是关注同一网站在不同设备里和不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。
优雅降级认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器的前一个版本。在这种设计下，旧版的浏览器被认为仅能提供最简单的的浏览体验
渐进增强认为应关注于内容本身。会优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性，这使得渐进增强成为一种更为合理的设计范例

### 代码举例

```css
.transition { /渐进增强写法，先关注最高级的再考虑兼容/
-webkit-transition: all .5s;
-moz-transition: all .5s;
-o-transition: all .5s;
transition: all .5s;
}
.transition { /优雅降级写法，先考虑兼容/
transition: all .5s;
-o-transition: all .5s;
-moz-transition: all .5s;
-webkit-transition: all .5s;
}
```

## viewport常见设置有哪些

viewport在前端开发中是一个重要的概念，特别是在进行响应式设计和移动Web开发时。它主要用于设置网页在移动设备上的可视区域，以确保网页能够正确地适应不同尺寸的屏幕。以下是viewport的一些常见设置：
**width**：设置viewport的宽度。这个值可以是一个具体的像素值，也可以是特殊的值，如'device-width'，表示设备的屏幕宽度。使用'device-width'可以确保网页的宽度与设备的屏幕宽度相匹配，从而避免水平滚动条的出现。
**initial-scale**：设置网页首次加载时的缩放比例。这个值是一个数值，表示相对于原始大小的缩放倍数。例如，1.0表示不缩放，即按照原始大小显示。这个属性通常与width属性一起使用，以确保网页在加载时能够正确地适应屏幕。
**maximum-scale** 和 **minimum-scale**：分别设置用户允许缩放的最大比例和最小比例。这两个属性可以防止用户过度缩放网页，从而保持网页的布局和可读性。
**user-scalable**：设置是否允许用户手动缩放网页。这个属性可以接受两个值：'yes'或'no'。如果设置为'no'，则用户无法通过手势或浏览器控件来缩放网页。这有助于保持网页的布局稳定性，但也可能限制用户的交互体验。

综上所述，一个常见的viewport设置示例如下：
在前端开发中，meta视口标签是构建响应式网页不可缺或缺的一部分，它位于HTML文档的头部，这个标签的作用是告诉浏览器如何控制页面的尺寸和缩放比例。视口标签的一般格式如下：
`<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">`
这个设置将viewport的宽度设置为设备的屏幕宽度，初始缩放比例为1.0，并禁止用户手动缩放网页。这样的设置通常适用于响应式设计，可以确保网页在不同设备上都能够正确地显示和布局。

## 标签语义化的理解

<https://segmentfault.com/a/1190000045465892>

## html5中的form怎么关闭自动完成功能

<https://docs.pingcode.com/baike/3090637>

## ::before和::after中单冒号和双冒号的区别

伪类使用单冒号表示，伪元素既可以是单冒号，也可以是双冒号，规范使用建议是双冒号。

* **::before** 伪元素：用于在选定元素的内容前插入一个生成的内容。它允许在元素的开始位置插入额外的样式化内容，通常用于添加装饰性的元素或图标。
例如，可以使用 ::before 创建一个元素的前置图标。
* **::after** 伪元素：用于在选定元素的内容后插入一个生成的内容。它允许在元素的结束位置插入额外的样式化内容，通常用于添加装饰性的元素或生成清除浮动的伪元素。
例如，可以使用 ::after 创建一个元素的尾部装饰。
这两个伪元素的内容可以通过 content 属性来定义（content不能没有，内容至少为空；伪元素的display默认为inline）。

### 常见的伪元素

* ::first-line：用于选中元素的第一行文本，可以对其应用特定的样式。
* ::first-letter：用于选中元素的第一个字母，可以对其应用特定的样式。
* ::selection：用于选中文本时的样式，例如文本的背景色和文本颜色等。
* ::placeholder：用于设置表单元素的占位符文本的样式，允许自定义占位符文本的颜色、字体等。

### 常见的伪类

单冒号(:)用于表示 CSS 中的伪类，它们是一些用于选择特定状态或特定位置的元素的类别。以下是一些常见的单冒号伪类：

* :hover：当鼠标悬停在元素上时应用的样式。
* :active：当元素被激活或被点击时应用的样式。
* :focus：当元素获得焦点时应用的样式，通常在用户与表单元素进行交互时使用。
* :visited：选择已访问过的链接的样式。
* :first-child：选择父元素下的第一个子元素。
* :last-child：选择父元素下的最后一个子元素。
* :nth-child(n)：选择父元素下的第 n 个子元素。
* :nth-of-type(n)：选择父元素下同类型元素中的第 n 个元素。
* :not(selector)：选择不满足指定选择器的元素。
* :empty：选择没有子元素或者没有文本内容的元素

## 常见状态码

||类别|原因短语|
|-|--|--|
|1xx|Informational（信息状态码）|接受的请求正在处理|
|2xx|Success（成功状态码）|请求正常处理完毕|
|3xx|Redirection（重定向状态码）|需要进行附加操作以完成请求|
|4xx|Client Error（客户端错误状态码）|服务器无法处理请求|
|5xx|Server Error（服务器错误状态码）|服务器处理请求报错|

### 2XX 成功

* 200 ok（请求成功）
* 204 no content （请求成功，但是没有结果返回）
* 206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）

### 3XX 重定向

* 301 move permanently （永久性重定向）
* 302 found （临时性重定向）
* 303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET

### 方法定向获取请求的资源）

* 304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）
* 307 temporary redirect （跟302一个意思）

### 4XX 客户端错误

* 400 bad request （请求报文存在语法错误）
* 401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））
* 403 forbidden （请求被服务器拒绝了）
* 404 not found （服务器上无法找到请求的资源）

### 5XX 服务器错误

* 500 internal server error （服务端执行请求时发生了错误）
* 503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）

## 为什么HTML5只需要写`<!DOCTYPE html>`就可以

在Web开发的早期，定义文档类型（DOCTYPE）是确保浏览器正确解析和显示网页的关键步骤。随着HTML的进化，HTML5简化了DOCTYPE声明，只需要写`<!DOCTYPE html>`。

### DOCTYPE的历史背景

在HTML4及之前的版本中，DOCTYPE声明是非常复杂的，并且与特定的DTD（Document Type Defination）相关联。DOCTYPE的主要目的是告诉浏览器使用哪种HTML或XML规则来解析文档。如果没有正确说明，浏览器可能会进入怪异模式（Quirks Mode），导致页面渲染不一致。

* HTML4的一个典型DOCTYPE声明如下
`<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">`
这种声明不仅冗长，而且容易出错，给开发者带来了不少困扰。

### HTML5的简化

HTML5的设计目标之一是简化Web开发过程，并提高兼容性和易用性。因此，HTML5的DOCTYPE声明被大大就简化，只需要`<!DOCTYPE html>`
这种简化的声明具有以下几个显著优势：

* 1、简洁明了
HTML5的DOCTYPE声明非常简洁，只需要一行代码就能完成。这使得文档结构更加清晰，减少了开发者记忆和输入的负担。
* 2、浏览器兼容性
尽管DOCTYPE声明在不同的HTML版本中有所不同，HTML5的简化声明在所有现代浏览器中都能正常工作。浏览器会将其解释为标准模式（Standards Mode），从而确保页面的一直渲染。这种统一性极大地减少了浏览器兼容性问题。
* 3、向前向后兼容
HTML5的DOCTYPE声明不仅向前兼容（适用于未来的HTML版本），还向后兼容（适用于旧的HTML版本），这意味着你在使用HTML5的DOCTYPE声明，旧的HTML4文档也能正常显示，而且新的HTML5特性也能无缝集成。
* 4、降低学习曲线
对于新手开发者来说，简化的DOCTYPE声明大大降低了学习曲线。他们不再需要记住复杂的DTD声明，只需记住一个简单的`<!DOCTYPE html>`即可。这样，可以更快地上手网页开发，专注于内容和功能本身。
* 5、符合HTML5哲学
HTML5强调简单和实用，这种哲学贯穿了整个规范的设计。简化的DOCTYPE声明正是这种哲学的体现，使得Web开发变得更加直观和易于维护。
**总结**
HTML5之所以只需要简化的`<!DOCTYPE html>`声明，主要是为了简化开发过程、提高浏览器兼容性、降低学习曲线，并且符合HTML5强调简单和实用的设计哲学。这种简化不仅使得Web开发更加高效，也确保了未来的兼容性和扩展性。通过采用这个简单的声明，开发者可以更专注于页面内容和功能，而不必担心复杂的DTD声明带来的麻烦。

## title与h1的区别、b与strong的区别、i与em的区别？

### 一、title与h1的区别

* 1、作用与重要性
  * title：主要用于定义整个网页的标题，它会显示在浏览器的标题栏或标签页上。对于搜索引擎优化（SEO）而言，title标签非常重要，因为它能直接告诉搜索引擎和用户这个网站的主题内容。
  * h1：用于概括网页或文章的主题，通常被视为页面内容的主要标题。在SEO中，h1标签也具有较高的权重。
* 2、使用频率与位置
  * 每个网页通常只有一个title标签，且应位于head部分。
  * h1标签在页面中可以有多个，但从结构化和SEO角度看，推荐页面只有一个主要的h1标签，通常位于页面的顶部或内容区域的开始部分。

### 二、b与strong的区别

* 1、样式与语义：
  * b：仅仅是将文本加粗显示，没有额外的语义。
  * strong：不仅将文本加粗，还表示强调的语义。它告诉搜索引擎这部分文本是最重要的。
* 2、搜索引擎优化（SEO）
  * 由于strong标签具有强调的语义，搜索引擎在抓取页面时可能更倾向于关注被strong标签包围的文本。

### 三、i与em的区别

* 1、样式与定义
  * i：用于使文本倾斜显示，但没有特定的语义含义。它通常用于表示技术术语、外来语等，主要是为了表现形式上的变化。
  * em：表示强调文本内容，默认以斜体显示。与i不同，em具有强调的语义含义。
* 2、使用场景
  * i标签更多用于字体图标或特定术语的展示。
  * em标签则用于强调文本中的重要内容，帮助读者更快的理解作者想要突出的信息点。

## 元素的alt和title有什么区别

* alt：最常见用在img标签上，alt属性指定了代替文本，用于在图像无法显示或者用户禁用图像时，代替图像显示在浏览器中的内容。
用法：alt属性只能用在img、area和input元素中（包括 applet 元素）。对于input元素，alt属性意在用来替换提交按钮的图片。比如：`<input type="image" src="image.gif" alt="Submit" />`
* title：title属性规定元素的额外信息，这些信息通常会在鼠标移到元素上时显示一段工具提示文本。title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。

## 父子元素margin边界叠加是什么及解决方案

margin边界叠加，也称为外边距重叠，是CSS中的一个现象，发生在两个或多个块级盒子的垂直相邻边界之间。当这些边界相遇且其间没有任何非空内容、补白（padding）或边框（border）时，它们会重合在一起，形成一个单一边界。重叠后的外边距宽度等于相邻边界宽度中的最大值。如果存在负边界，则在最大的正边界中减去绝对值最大的负边界；如果没有正边界，则从零中减去绝对值最大的负边界。
以下是关于margin边界叠加的解决方案：

* **使用外层元素的padding代替**：给外层元素添加padding可以防止内层元素的margin产生重叠。这是因为padding是元素边框与内容之间的空间，它不会被视为边界重叠的一部分。
* **外层元素使用透明边框**：为内层元素添加透明的边框也可以防止margin重叠。即使边框是透明的，它仍然占据空间，从而阻止了相邻元素的margin相互重叠。
* **内层元素绝对定位**：将内层元素设置为绝对定位（position: absolute;）可以使其脱离常规文档流，从而避免与相邻元素的margin产生重叠。但请注意，绝对定位可能会导致布局上的其他问题，需要谨慎使用。
* **外层元素使用overflow属性**：为外层元素设置overflow属性（除了visible值）可以创建一个新的块级上下文，从而防止其子元素的margin与外部元素产生重叠。常用的值包括hidden、auto或scroll。
* **内层或外层元素使用float或display属性**：将内层或外层元素设置为浮动（如float: left;）或更改其显示类型（如display: inline-block;）也可以防止margin重叠。这些方法会改变元素的布局行为，但在某些情况下可能是有效的解决方案。
总的来说，解决margin边界叠加的方法取决于具体的布局需求和上下文环境。在选择解决方案时，需要权衡各种方法的优缺点，并考虑到它们对整体布局的影响。

## 你认为table的作用和优缺点是什么

### 优点

* 结构化数据展示：表格最主要的优点是能够以清晰的行列结构展示数据，方便用户理解和分析数据之间的关系。 尤其适用于包含大量数值或需要进行比较的数据。
* 语义化：`<table>` 元素本身就带有语义，这有助于屏幕阅读器等辅助技术理解表格内容，提升网页的可访问性。
* 内置排序和筛选：虽然需要 JavaScript 实现，但表格结构天然支持排序和筛选功能，方便用户对数据进行操作。
* 跨浏览器兼容性好：表格元素是 HTML 的基础元素，拥有良好的跨浏览器兼容性，开发者无需担心兼容性问题。
* 易于样式控制：可以通过 CSS 对表格的外观进行灵活的控制，例如边框、颜色、字体等，使其符合整体设计风格。

### 缺点

* 响应式设计困难：在不同的屏幕尺寸下，表格的布局可能会出现问题，难以适应移动设备。虽然可以通过媒体查询和一些技巧来改善，但仍然比较复杂。
* 语义化局限性：表格只适合展示结构化数据，如果用于布局页面，则会造成语义混乱，不利于 SEO 和可访问性。 应该避免使用表格进行页面布局。
* 性能问题：当表格数据量非常大时，渲染速度可能会变慢，影响用户体验。 需要进行优化，例如分页加载、虚拟滚动等。
* 复杂布局实现困难：对于复杂的表格布局，例如合并单元格、不规则表格等，实现起来比较复杂，需要额外的代码和技巧。
* 默认样式单调：表格的默认样式比较简单，通常需要自定义 CSS 样式来美化外观。

### 总结

表格在展示结构化数据方面非常有效，但在响应式设计和复杂布局方面存在一些局限性。 开发者需要根据实际情况选择是否使用表格，并采取相应的优化措施来提升用户体验。 如果数据并非结构化的，或者需要复杂的布局，应该考虑使用其他更合适的 HTML 元素，例如`<div>`和CSS Grid或Flexbox布局。

## 怎样在页面上实现一个圆形的可点击区域

### 一、通过map加area

`<img>`标签中的usermap属性将图像定义为客户端图像时。图像映射指的是带有可点击区域的图像。usermap属性与`<map>`元素的name或id属性相关联。
这里通过usermap映射到`<map>`的circle形`<area>`。
`<area>`标签类似`<img>`，是无法有子元素或其他子内容的。

* shape表示点击热点区域的形状，支持矩形react，圆形circle及多边形poly。
* 表示点击热点区域形状的坐标。圆形circle支持3个数值，前两个值为圆心坐标，第三个值为圆的半径大小。
* href和`<a>`元素的href是一样的东西，直接跳转地址，或者锚点等。也同样支持target属性和rel属性。也就是说`<area>`可以看成是半个`<a>`元素。

```html
<img src="images/lanlvseImg.png" usemap="#Map" />  
<map name="Map" id="Map">
 <area shape="circle" coords="100,100,50" href="http://www.baidu.com" target="_blank"/>
</map>
```

### 二、border-radius

设置div的border-radius:50%。

```css
<div id="circle"></div>
#circle{
 background:red;
 width:100px;
 height:100px;
 border-radius:50%;
}
```

### 三、js实现，获取鼠标点击位置坐标，判断其到圆点的距离是否不大于圆的半径，来判断点击位置是否在圆内

两点之间的距离计算公式：`|AB|=Math.abs(Math.sqrt(Math.pow(X2-X1), 2) + Math.pow(Y2-Y1, 2)))` Math.abs()求绝对值，Math.pow(底数,指数)，Math.sqrt()求平方根

```js
// 获取目标元素
var box = document.getElementById('box');
 
// 对目标元素target的圆形区域进行一个点击事件绑定
function bindClickOnCircleArea(target, callback) {
  target.onclick = function (e) {
    e = e || window.event;
 
    // target中心点的坐标
    var x1 = 100;
    var y1 = 100;
 
    // 事件源坐标
    var x2 = e.offsetX;
    var y2 = e.offsetY;
 
    // 校验是否在圆形点击区，在的话就执行callback回调
    // 计算事件触发点与target中心的位置
    var len = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));
    // 通过半径进行校验
    if (len <= 100) {
      callback();
    } else {
      alert('在外面');
    }
  }
}
 
// 执行
bindClickOnCircleArea(box, function () {
  alert('找到了');
});
```

## 说说你对html中的置换元素和非置换元素的理解

在HTML中，元素可以大致分为置换元素和非置换元素。他们的区别在于内容的渲染方式：

### 置换元素

定义：内容的渲染不由CSS控制，而是外部资源决定，例如图像、视频、音频、表单控件等。HTML只提供占位，实际内容有浏览器根据元素的属性（例如：src，type）从外部获取渲染。
特点：

* 内容不在HTML文档流中。这意味着对他们的样式设置，尤其是width和height，会直接影响元素本身的大小，而不是内容的大小。如果未指定大小，则会使用元素固有的尺寸（例如图片的原始宽度和高度）。
* 忽略一些CSS属性，例如line-height、vertical-align（部分属性可能对元素的布局有影响，但不会影响元素内部内容的排列）。
* 浏览器负责渲染元素的内容，HTML和CSS只控制元素的位置和一些基本样式。
常见例子：
* `<img>`（图像）
* `<video>`（视频）
* `<audio>`（音频）
* `<iframe>`（内联框架）
* `<object>`（嵌入对象）
* `<input>`（表单输入，部分类型，例如file、image、button等）
* `<textarea>`（文本域，特殊情况，内容由用户输入，但尺寸由元素控制）

### 非置换元素

定义：内容由HTML和CSS直接控制渲染。浏览器根据HTML标签和CSS样式规则来确定元素的内容和外观。
特点：

* 内容在HTML文档流中。CSS样式会影响元素内容的布局和外观。
* 遵循CSS盒模型规则。padding、margin、border等属性会影响元素的整体大小。
* 大多数CSS属性都适用。
常见例子：几乎所有的HTML元素
理解的关键区别：想象一下画框。对于非置换元素，HTML提供了内容（例如文字），CSS规则项像画笔一样，决定了内容的颜色、字体等样式，以及框的大小和位置。而对于置换元素，HTML只提供了框，内容（例如图片）来自外部，CSS只能控制框的大小和位置，无法影响内容本身。

## 请描述HTML元素的显示优先级

在HTML和CSS中，元素的显示优先级主要由以下几个因素决定：

* HTML源代码顺序：在HTML中，元素的默认堆叠顺序（z-index）是由他们在源代码中的顺序决定的。后出现的元素会覆盖先出现的元素（如果他们在空间上重叠）。
* CSS的z-index属性：z-index属性用于设置元素的堆叠顺序。一个元素的z-index值越高，它就越在堆叠顺序的顶部，也就越能覆盖其他元素。需要注意的是，z-index只对设置了position属性（且值不为static）的元素有效。
* CSS的position属性：这个属性决定了元素如何在页面上定位，以及它们如何与其他元素进行交互。例如：absolute和fixed定位的元素可以脱离文档流，而relative定位的元素则仍然保留在文档流中，这些定位方式也会影响元素的堆叠顺序。
* 元素的显示属性：例如：display:none会将元素从页面布局中完全移除，而visibility:hidden则会使元素不可见但仍占据空间。这些属性虽然不直接影响堆叠顺序，但会改变元素的可见性和布局。
* !important规则：在CSS中!important规则可以覆盖其他相同属性样式声明。虽然它主要用于解决样式冲突，但在某些情况下，它也可能影响元素的显示优先级。
* CSS选择器的特异性：CSS选择器的特异性（或优先级）也会影响样式的应用。例如：id选择器的特异性高于类选择器和标签选择器。如果多个样式规则适用于同一个元素，那么具有更高特异性的规则将优先应用。
需要注意的是，虽然上述因素会影响元素的显示优先级，但他们之间并不是简单的线性关系。在实际开发中，可能需要根据具体情况综合考虑多个因素来确定元素的最终显示效果。
另外除HTML和CSS之外，JavaScript也可以通过动态修改元素的样式或DOM结构来改变元素的显示优先级。例如：通过JavaScript可以动态添加或删除CSS类、改变元素的z-index值等。
